"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoticeFilter = exports.CachedDataSource = exports.WebsiteNoticeDataSource = exports.formatNotices = exports.filterNotices = exports.generateMessage = exports.displayNotices = exports.refreshNotices = void 0;
const https = require("https");
const path = require("path");
const fs = require("fs-extra");
const semver = require("semver");
const logging_1 = require("./logging");
const tree_1 = require("./tree");
const util_1 = require("./util");
const directories_1 = require("./util/directories");
const version_1 = require("./version");
const CACHE_FILE_PATH = path.join((0, directories_1.cdkCacheDir)(), 'notices.json');
async function refreshNotices() {
    const dataSource = dataSourceReference(false);
    return dataSource.fetch();
}
exports.refreshNotices = refreshNotices;
async function displayNotices(props) {
    const dataSource = dataSourceReference(props.ignoreCache ?? false);
    (0, logging_1.print)(await generateMessage(dataSource, props));
    return 0;
}
exports.displayNotices = displayNotices;
async function generateMessage(dataSource, props) {
    const data = await dataSource.fetch();
    const filteredNotices = filterNotices(data, {
        outdir: props.outdir,
        acknowledgedIssueNumbers: new Set(props.acknowledgedIssueNumbers),
    });
    let messageString = '';
    if (filteredNotices.length > 0) {
        messageString = getFilteredMessages(filteredNotices);
    }
    if (props.unacknowledged) {
        messageString = [messageString, `There are ${filteredNotices.length} unacknowledged notice(s).`].join('\n\n');
    }
    return messageString;
}
exports.generateMessage = generateMessage;
function getFilteredMessages(filteredNotices) {
    const individualMessages = formatNotices(filteredNotices);
    return finalMessage(individualMessages, filteredNotices[0].issueNumber);
}
function dataSourceReference(ignoreCache) {
    return new CachedDataSource(CACHE_FILE_PATH, new WebsiteNoticeDataSource(), ignoreCache);
}
function finalMessage(individualMessages, exampleNumber) {
    return [
        '\nNOTICES         (What\'s this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)',
        ...individualMessages,
        `If you donâ€™t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${exampleNumber}".`,
    ].join('\n\n');
}
function filterNotices(data, options) {
    const filter = new NoticeFilter({
        cliVersion: options.cliVersion ?? (0, version_1.versionNumber)(),
        acknowledgedIssueNumbers: options.acknowledgedIssueNumbers ?? new Set(),
        tree: (0, tree_1.loadTreeFromDir)(options.outdir ?? 'cdk.out'),
    });
    return data.filter(notice => filter.apply(notice));
}
exports.filterNotices = filterNotices;
function formatNotices(data) {
    return data.map(formatNotice);
}
exports.formatNotices = formatNotices;
class WebsiteNoticeDataSource {
    fetch() {
        const timeout = 3000;
        return new Promise((resolve, reject) => {
            let req;
            let timer = setTimeout(() => {
                if (req) {
                    req.destroy(new Error('Request timed out'));
                }
            }, timeout);
            timer.unref();
            try {
                req = https.get('https://cli.cdk.dev-tools.aws.dev/notices.json', res => {
                    if (res.statusCode === 200) {
                        res.setEncoding('utf8');
                        let rawData = '';
                        res.on('data', (chunk) => {
                            rawData += chunk;
                        });
                        res.on('end', () => {
                            try {
                                const data = JSON.parse(rawData).notices;
                                if (!data) {
                                    throw new Error("'notices' key is missing");
                                }
                                (0, logging_1.debug)('Notices refreshed');
                                resolve(data ?? []);
                            }
                            catch (e) {
                                reject(new Error(`Failed to parse notices: ${e.message}`));
                            }
                        });
                        res.on('error', e => {
                            reject(new Error(`Failed to fetch notices: ${e.message}`));
                        });
                    }
                    else {
                        reject(new Error(`Failed to fetch notices. Status code: ${res.statusCode}`));
                    }
                });
                req.on('error', reject);
            }
            catch (e) {
                reject(new Error(`HTTPS 'get' call threw an error: ${e.message}`));
            }
        });
    }
}
exports.WebsiteNoticeDataSource = WebsiteNoticeDataSource;
const TIME_TO_LIVE_SUCCESS = 60 * 60 * 1000; // 1 hour
const TIME_TO_LIVE_ERROR = 1 * 60 * 1000; // 1 minute
class CachedDataSource {
    constructor(fileName, dataSource, skipCache) {
        this.fileName = fileName;
        this.dataSource = dataSource;
        this.skipCache = skipCache;
    }
    async fetch() {
        const cachedData = await this.load();
        const data = cachedData.notices;
        const expiration = cachedData.expiration ?? 0;
        if (Date.now() > expiration || this.skipCache) {
            const freshData = await this.fetchInner();
            await this.save(freshData);
            return freshData.notices;
        }
        else {
            (0, logging_1.debug)(`Reading cached notices from ${this.fileName}`);
            return data;
        }
    }
    async fetchInner() {
        try {
            return {
                expiration: Date.now() + TIME_TO_LIVE_SUCCESS,
                notices: await this.dataSource.fetch(),
            };
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
            return {
                expiration: Date.now() + TIME_TO_LIVE_ERROR,
                notices: [],
            };
        }
    }
    async load() {
        const defaultValue = {
            expiration: 0,
            notices: [],
        };
        try {
            return fs.existsSync(this.fileName)
                ? await fs.readJSON(this.fileName)
                : defaultValue;
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to load notices from cache: ${e}`);
            return defaultValue;
        }
    }
    async save(cached) {
        try {
            await fs.writeJSON(this.fileName, cached);
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to store notices in the cache: ${e}`);
        }
    }
}
exports.CachedDataSource = CachedDataSource;
class NoticeFilter {
    constructor(props) {
        this.props = props;
        this.acknowledgedIssueNumbers = props.acknowledgedIssueNumbers;
    }
    /**
     * Returns true if we should show this notice.
     */
    apply(notice) {
        if (this.acknowledgedIssueNumbers.has(notice.issueNumber)) {
            return false;
        }
        return this.applyVersion(notice, 'cli', this.props.cliVersion) ||
            match(resolveAliases(notice.components), this.props.tree);
    }
    /**
     * Returns true if we should show the notice.
     */
    applyVersion(notice, name, compareToVersion) {
        if (compareToVersion === undefined) {
            return false;
        }
        const affectedComponent = notice.components.find(component => component.name === name);
        const affectedRange = affectedComponent?.version;
        return affectedRange != null && semver.satisfies(compareToVersion, affectedRange);
    }
}
exports.NoticeFilter = NoticeFilter;
/**
 * Some component names are aliases to actual component names. For example "framework"
 * is an alias for either the core library (v1) or the whole CDK library (v2).
 *
 * This function converts all aliases to their actual counterpart names, to be used to
 * match against the construct tree.
 *
 * @param components a list of components. Components whose name is an alias will be
 * transformed and all others will be left intact.
 */
function resolveAliases(components) {
    return (0, util_1.flatMap)(components, component => {
        if (component.name === 'framework') {
            return [{
                    name: '@aws-cdk/core.',
                    version: component.version,
                }, {
                    name: 'aws-cdk-lib.',
                    version: component.version,
                }];
        }
        else {
            return [component];
        }
    });
}
function formatNotice(notice) {
    const componentsValue = notice.components.map(c => `${c.name}: ${c.version}`).join(', ');
    return [
        `${notice.issueNumber}\t${notice.title}`,
        formatOverview(notice.overview),
        `\tAffected versions: ${componentsValue}`,
        `\tMore information at: https://github.com/aws/aws-cdk/issues/${notice.issueNumber}`,
    ].join('\n\n') + '\n';
}
function formatOverview(text) {
    const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
    const heading = 'Overview: ';
    const separator = `\n\t${' '.repeat(heading.length)}`;
    const content = wrap(text)
        .split('\n')
        .join(separator);
    return '\t' + heading + content;
}
/**
 * Whether any component in the tree matches any component in the query.
 * A match happens when:
 *
 * 1. The version of the node matches the version in the query, interpreted
 * as a semver range.
 *
 * 2. The name in the query is a prefix of the node name when the query ends in '.',
 * or the two names are exactly the same, otherwise.
 */
function match(query, tree) {
    return (0, tree_1.some)(tree, node => {
        return query.some(component => compareNames(component.name, node.constructInfo?.fqn) &&
            compareVersions(component.version, node.constructInfo?.version));
    });
    function compareNames(pattern, target) {
        if (target == null) {
            return false;
        }
        return pattern.endsWith('.') ? target.startsWith(pattern) : pattern === target;
    }
    function compareVersions(pattern, target) {
        return semver.satisfies(target ?? '', pattern);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLHVDQUF5QztBQUN6QyxpQ0FBa0U7QUFDbEUsaUNBQWlDO0FBQ2pDLG9EQUFpRDtBQUNqRCx1Q0FBMEM7QUFFMUMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFBLHlCQUFXLEdBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQztBQThCMUQsS0FBSyxVQUFVLGNBQWM7SUFDbEMsTUFBTSxVQUFVLEdBQUcsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUMsT0FBTyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDNUIsQ0FBQztBQUhELHdDQUdDO0FBRU0sS0FBSyxVQUFVLGNBQWMsQ0FBQyxLQUEwQjtJQUM3RCxNQUFNLFVBQVUsR0FBRyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsV0FBVyxJQUFJLEtBQUssQ0FBQyxDQUFDO0lBQ25FLElBQUEsZUFBSyxFQUFDLE1BQU0sZUFBZSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2hELE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQUpELHdDQUlDO0FBRU0sS0FBSyxVQUFVLGVBQWUsQ0FBQyxVQUE0QixFQUFFLEtBQTBCO0lBQzVGLE1BQU0sSUFBSSxHQUFHLE1BQU0sVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3RDLE1BQU0sZUFBZSxHQUFHLGFBQWEsQ0FBQyxJQUFJLEVBQUU7UUFDMUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO1FBQ3BCLHdCQUF3QixFQUFFLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQztLQUNsRSxDQUFDLENBQUM7SUFFSCxJQUFJLGFBQWEsR0FBVyxFQUFFLENBQUM7SUFDL0Is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QUFDO1NBQ3ZCLEtBQUssQ0FBQyxJQUFJLENBQUM7U0FDWCxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFFbkIsT0FBTyxJQUFJLEdBQUcsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUNsQyxDQUFDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBUyxLQUFLLENBQUMsS0FBa0IsRUFBRSxJQUF1QjtJQUN4RCxPQUFPLElBQUEsV0FBSSxFQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRTtRQUN2QixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FDNUIsWUFBWSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUM7WUFDckQsZUFBZSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUMsQ0FBQyxDQUFDO0lBRUgsU0FBUyxZQUFZLENBQUMsT0FBZSxFQUFFLE1BQTBCO1FBQy9ELElBQUksTUFBTSxJQUFJLElBQUksRUFBRSxDQUFDO1lBQUMsT0FBTyxLQUFLLENBQUM7UUFBQyxDQUFDO1FBQ3JDLE9BQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLE1BQU0sQ0FBQztJQUNqRixDQUFDO0lBRUQsU0FBUyxlQUFlLENBQUMsT0FBZSxFQUFFLE1BQTBCO1FBQ2xFLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2pELENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpZW50UmVxdWVzdCB9IGZyb20gJ2h0dHAnO1xuaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgZGVidWcsIHByaW50IH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IENvbnN0cnVjdFRyZWVOb2RlLCBsb2FkVHJlZUZyb21EaXIsIHNvbWUgfSBmcm9tICcuL3RyZWUnO1xuaW1wb3J0IHsgZmxhdE1hcCB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBjZGtDYWNoZURpciB9IGZyb20gJy4vdXRpbC9kaXJlY3Rvcmllcyc7XG5pbXBvcnQgeyB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi92ZXJzaW9uJztcblxuY29uc3QgQ0FDSEVfRklMRV9QQVRIID0gcGF0aC5qb2luKGNka0NhY2hlRGlyKCksICdub3RpY2VzLmpzb24nKTtcblxuZXhwb3J0IGludGVyZmFjZSBEaXNwbGF5Tm90aWNlc1Byb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBjbG91ZCBhc3NlbWJseSBkaXJlY3RvcnkuIFVzdWFsbHkgJ2Nkay5vdXQnLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0ZGlyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElzc3VlIG51bWJlcnMgb2Ygbm90aWNlcyB0aGF0IGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgYnkgYSB1c2VyXG4gICAqIG9mIHRoZSBjdXJyZW50IENESyByZXBvc2l0b3J5LiBUaGVzZSBub3RpY2VzIHdpbGwgYmUgc2tpcHBlZC5cbiAgICovXG4gIHJlYWRvbmx5IGFja25vd2xlZGdlZElzc3VlTnVtYmVyczogbnVtYmVyW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgY2FjaGVkIG5vdGljZXMgc2hvdWxkIGJlIGlnbm9yZWQuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eVxuICAgKiB0byB0cnVlIHdpbGwgZm9yY2UgdGhlIENMSSB0byBkb3dubG9hZCBmcmVzaCBkYXRhXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBpZ25vcmVDYWNoZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYXBwZW5kIHRoZSBudW1iZXIgb2YgdW5hY2tub3dsZWRnZWQgbm90aWNlcyB0byB0aGUgZGlzcGxheS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHVuYWNrbm93bGVkZ2VkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hOb3RpY2VzKCkge1xuICBjb25zdCBkYXRhU291cmNlID0gZGF0YVNvdXJjZVJlZmVyZW5jZShmYWxzZSk7XG4gIHJldHVybiBkYXRhU291cmNlLmZldGNoKCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNwbGF5Tm90aWNlcyhwcm9wczogRGlzcGxheU5vdGljZXNQcm9wcykge1xuICBjb25zdCBkYXRhU291cmNlID0gZGF0YVNvdXJjZVJlZmVyZW5jZShwcm9wcy5pZ25vcmVDYWNoZSA/PyBmYWxzZSk7XG4gIHByaW50KGF3YWl0IGdlbmVyYXRlTWVzc2FnZShkYXRhU291cmNlLCBwcm9wcykpO1xuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTWVzc2FnZShkYXRhU291cmNlOiBOb3RpY2VEYXRhU291cmNlLCBwcm9wczogRGlzcGxheU5vdGljZXNQcm9wcykge1xuICBjb25zdCBkYXRhID0gYXdhaXQgZGF0YVNvdXJjZS5mZXRjaCgpO1xuICBjb25zdCBmaWx0ZXJlZE5vdGljZXMgPSBmaWx0ZXJOb3RpY2VzKGRhdGEsIHtcbiAgICBvdXRkaXI6IHByb3BzLm91dGRpcixcbiAgICBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IG5ldyBTZXQocHJvcHMuYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzKSxcbiAgfSk7XG5cbiAgbGV0IG1lc3NhZ2VTdHJpbmc6IHN0cmluZyA9ICcnO1xuICBpZiAoZmlsdGVyZWROb3RpY2VzLmxlbmd0aCA+IDApIHtcbiAgICBtZXNzYWdlU3RyaW5nID0gZ2V0RmlsdGVyZWRNZXNzYWdlcyhmaWx0ZXJlZE5vdGljZXMpO1xuICB9XG4gIGlmIChwcm9wcy51bmFja25vd2xlZGdlZCkge1xuICAgIG1lc3NhZ2VTdHJpbmcgPSBbbWVzc2FnZVN0cmluZywgYFRoZXJlIGFyZSAke2ZpbHRlcmVkTm90aWNlcy5sZW5ndGh9IHVuYWNrbm93bGVkZ2VkIG5vdGljZShzKS5gXS5qb2luKCdcXG5cXG4nKTtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVN0cmluZztcbn1cblxuZnVuY3Rpb24gZ2V0RmlsdGVyZWRNZXNzYWdlcyhmaWx0ZXJlZE5vdGljZXM6IE5vdGljZVtdKTogc3RyaW5nIHtcbiAgY29uc3QgaW5kaXZpZHVhbE1lc3NhZ2VzID0gZm9ybWF0Tm90aWNlcyhmaWx0ZXJlZE5vdGljZXMpO1xuICByZXR1cm4gZmluYWxNZXNzYWdlKGluZGl2aWR1YWxNZXNzYWdlcywgZmlsdGVyZWROb3RpY2VzWzBdLmlzc3VlTnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gZGF0YVNvdXJjZVJlZmVyZW5jZShpZ25vcmVDYWNoZTogYm9vbGVhbik6IE5vdGljZURhdGFTb3VyY2Uge1xuICByZXR1cm4gbmV3IENhY2hlZERhdGFTb3VyY2UoQ0FDSEVfRklMRV9QQVRILCBuZXcgV2Vic2l0ZU5vdGljZURhdGFTb3VyY2UoKSwgaWdub3JlQ2FjaGUpO1xufVxuXG5mdW5jdGlvbiBmaW5hbE1lc3NhZ2UoaW5kaXZpZHVhbE1lc3NhZ2VzOiBzdHJpbmdbXSwgZXhhbXBsZU51bWJlcjogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIFtcbiAgICAnXFxuTk9USUNFUyAgICAgICAgIChXaGF0XFwncyB0aGlzPyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvd2lraS9DTEktTm90aWNlcyknLFxuICAgIC4uLmluZGl2aWR1YWxNZXNzYWdlcyxcbiAgICBgSWYgeW91IGRvbuKAmXQgd2FudCB0byBzZWUgYSBub3RpY2UgYW55bW9yZSwgdXNlIFwiY2RrIGFja25vd2xlZGdlIDxpZD5cIi4gRm9yIGV4YW1wbGUsIFwiY2RrIGFja25vd2xlZGdlICR7ZXhhbXBsZU51bWJlcn1cIi5gLFxuICBdLmpvaW4oJ1xcblxcbicpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlck5vdGljZU9wdGlvbnMge1xuICBvdXRkaXI/OiBzdHJpbmc7XG4gIGNsaVZlcnNpb24/OiBzdHJpbmc7XG4gIGZyYW1ld29ya1ZlcnNpb24/OiBzdHJpbmc7XG4gIGFja25vd2xlZGdlZElzc3VlTnVtYmVycz86IFNldDxudW1iZXI+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyTm90aWNlcyhkYXRhOiBOb3RpY2VbXSwgb3B0aW9uczogRmlsdGVyTm90aWNlT3B0aW9ucyk6IE5vdGljZVtdIHtcbiAgY29uc3QgZmlsdGVyID0gbmV3IE5vdGljZUZpbHRlcih7XG4gICAgY2xpVmVyc2lvbjogb3B0aW9ucy5jbGlWZXJzaW9uID8/IHZlcnNpb25OdW1iZXIoKSxcbiAgICBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IG9wdGlvbnMuYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzID8/IG5ldyBTZXQoKSxcbiAgICB0cmVlOiBsb2FkVHJlZUZyb21EaXIob3B0aW9ucy5vdXRkaXIgPz8gJ2Nkay5vdXQnKSxcbiAgfSk7XG4gIHJldHVybiBkYXRhLmZpbHRlcihub3RpY2UgPT4gZmlsdGVyLmFwcGx5KG5vdGljZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Tm90aWNlcyhkYXRhOiBOb3RpY2VbXSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGRhdGEubWFwKGZvcm1hdE5vdGljZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50IHtcbiAgbmFtZTogc3RyaW5nO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgaXNzdWVOdW1iZXI6IG51bWJlcjtcbiAgb3ZlcnZpZXc6IHN0cmluZztcbiAgY29tcG9uZW50czogQ29tcG9uZW50W107XG4gIHNjaGVtYVZlcnNpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VEYXRhU291cmNlIHtcbiAgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT47XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBmZXRjaCgpOiBQcm9taXNlPE5vdGljZVtdPiB7XG4gICAgY29uc3QgdGltZW91dCA9IDMwMDA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZXE6IENsaWVudFJlcXVlc3QgfCB1bmRlZmluZWQ7XG5cbiAgICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgcmVxLmRlc3Ryb3kobmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVkIG91dCcpKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgIHRpbWVyLnVucmVmKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcSA9IGh0dHBzLmdldCgnaHR0cHM6Ly9jbGkuY2RrLmRldi10b29scy5hd3MuZGV2L25vdGljZXMuanNvbicsXG4gICAgICAgICAgcmVzID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIHJlcy5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgICAgICAgICBsZXQgcmF3RGF0YSA9ICcnO1xuICAgICAgICAgICAgICByZXMub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICByYXdEYXRhICs9IGNodW5rO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhd0RhdGEpLm5vdGljZXMgYXMgTm90aWNlW107XG4gICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ25vdGljZXMnIGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVidWcoJ05vdGljZXMgcmVmcmVzaGVkJyk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEgPz8gW10pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIG5vdGljZXM6ICR7ZS5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXMub24oJ2Vycm9yJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG5vdGljZXM6ICR7ZS5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlcy4gU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBIVFRQUyAnZ2V0JyBjYWxsIHRocmV3IGFuIGVycm9yOiAke2UubWVzc2FnZX1gKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIENhY2hlZE5vdGljZXMge1xuICBleHBpcmF0aW9uOiBudW1iZXI7XG4gIG5vdGljZXM6IE5vdGljZVtdO1xufVxuXG5jb25zdCBUSU1FX1RPX0xJVkVfU1VDQ0VTUyA9IDYwICogNjAgKiAxMDAwOyAvLyAxIGhvdXJcbmNvbnN0IFRJTUVfVE9fTElWRV9FUlJPUiA9IDEgKiA2MCAqIDEwMDA7IC8vIDEgbWludXRlXG5cbmV4cG9ydCBjbGFzcyBDYWNoZWREYXRhU291cmNlIGltcGxlbWVudHMgTm90aWNlRGF0YVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZmlsZU5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRhdGFTb3VyY2U6IE5vdGljZURhdGFTb3VyY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBza2lwQ2FjaGU/OiBib29sZWFuKSB7XG4gIH1cblxuICBhc3luYyBmZXRjaCgpOiBQcm9taXNlPE5vdGljZVtdPiB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGF3YWl0IHRoaXMubG9hZCgpO1xuICAgIGNvbnN0IGRhdGEgPSBjYWNoZWREYXRhLm5vdGljZXM7XG4gICAgY29uc3QgZXhwaXJhdGlvbiA9IGNhY2hlZERhdGEuZXhwaXJhdGlvbiA/PyAwO1xuXG4gICAgaWYgKERhdGUubm93KCkgPiBleHBpcmF0aW9uIHx8IHRoaXMuc2tpcENhY2hlKSB7XG4gICAgICBjb25zdCBmcmVzaERhdGEgPSBhd2FpdCB0aGlzLmZldGNoSW5uZXIoKTtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZShmcmVzaERhdGEpO1xuICAgICAgcmV0dXJuIGZyZXNoRGF0YS5ub3RpY2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhgUmVhZGluZyBjYWNoZWQgbm90aWNlcyBmcm9tICR7dGhpcy5maWxlTmFtZX1gKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hJbm5lcigpOiBQcm9taXNlPENhY2hlZE5vdGljZXM+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwaXJhdGlvbjogRGF0ZS5ub3coKSArIFRJTUVfVE9fTElWRV9TVUNDRVNTLFxuICAgICAgICBub3RpY2VzOiBhd2FpdCB0aGlzLmRhdGFTb3VyY2UuZmV0Y2goKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoYENvdWxkIG5vdCByZWZyZXNoIG5vdGljZXM6ICR7ZX1gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cGlyYXRpb246IERhdGUubm93KCkgKyBUSU1FX1RPX0xJVkVfRVJST1IsXG4gICAgICAgIG5vdGljZXM6IFtdLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWQoKTogUHJvbWlzZTxDYWNoZWROb3RpY2VzPiB7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0ge1xuICAgICAgZXhwaXJhdGlvbjogMCxcbiAgICAgIG5vdGljZXM6IFtdLFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZzLmV4aXN0c1N5bmModGhpcy5maWxlTmFtZSlcbiAgICAgICAgPyBhd2FpdCBmcy5yZWFkSlNPTih0aGlzLmZpbGVOYW1lKSBhcyBDYWNoZWROb3RpY2VzXG4gICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKGBGYWlsZWQgdG8gbG9hZCBub3RpY2VzIGZyb20gY2FjaGU6ICR7ZX1gKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlKGNhY2hlZDogQ2FjaGVkTm90aWNlcyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmcy53cml0ZUpTT04odGhpcy5maWxlTmFtZSwgY2FjaGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhgRmFpbGVkIHRvIHN0b3JlIG5vdGljZXMgaW4gdGhlIGNhY2hlOiAke2V9YCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlRmlsdGVyUHJvcHMge1xuICBjbGlWZXJzaW9uOiBzdHJpbmc7XG4gIGFja25vd2xlZGdlZElzc3VlTnVtYmVyczogU2V0PG51bWJlcj47XG4gIHRyZWU6IENvbnN0cnVjdFRyZWVOb2RlO1xufVxuXG5leHBvcnQgY2xhc3MgTm90aWNlRmlsdGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IFNldDxudW1iZXI+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IE5vdGljZUZpbHRlclByb3BzKSB7XG4gICAgdGhpcy5hY2tub3dsZWRnZWRJc3N1ZU51bWJlcnMgPSBwcm9wcy5hY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHdlIHNob3VsZCBzaG93IHRoaXMgbm90aWNlLlxuICAgKi9cbiAgYXBwbHkobm90aWNlOiBOb3RpY2UpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5hY2tub3dsZWRnZWRJc3N1ZU51bWJlcnMuaGFzKG5vdGljZS5pc3N1ZU51bWJlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseVZlcnNpb24obm90aWNlLCAnY2xpJywgdGhpcy5wcm9wcy5jbGlWZXJzaW9uKSB8fFxuICAgICAgbWF0Y2gocmVzb2x2ZUFsaWFzZXMobm90aWNlLmNvbXBvbmVudHMpLCB0aGlzLnByb3BzLnRyZWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBzaG91bGQgc2hvdyB0aGUgbm90aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseVZlcnNpb24obm90aWNlOiBOb3RpY2UsIG5hbWU6IHN0cmluZywgY29tcGFyZVRvVmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGNvbXBhcmVUb1ZlcnNpb24gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGNvbnN0IGFmZmVjdGVkQ29tcG9uZW50ID0gbm90aWNlLmNvbXBvbmVudHMuZmluZChjb21wb25lbnQgPT4gY29tcG9uZW50Lm5hbWUgPT09IG5hbWUpO1xuICAgIGNvbnN0IGFmZmVjdGVkUmFuZ2UgPSBhZmZlY3RlZENvbXBvbmVudD8udmVyc2lvbjtcbiAgICByZXR1cm4gYWZmZWN0ZWRSYW5nZSAhPSBudWxsICYmIHNlbXZlci5zYXRpc2ZpZXMoY29tcGFyZVRvVmVyc2lvbiwgYWZmZWN0ZWRSYW5nZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGNvbXBvbmVudCBuYW1lcyBhcmUgYWxpYXNlcyB0byBhY3R1YWwgY29tcG9uZW50IG5hbWVzLiBGb3IgZXhhbXBsZSBcImZyYW1ld29ya1wiXG4gKiBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIHRoZSBjb3JlIGxpYnJhcnkgKHYxKSBvciB0aGUgd2hvbGUgQ0RLIGxpYnJhcnkgKHYyKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGFsbCBhbGlhc2VzIHRvIHRoZWlyIGFjdHVhbCBjb3VudGVycGFydCBuYW1lcywgdG8gYmUgdXNlZCB0b1xuICogbWF0Y2ggYWdhaW5zdCB0aGUgY29uc3RydWN0IHRyZWUuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudHMgYSBsaXN0IG9mIGNvbXBvbmVudHMuIENvbXBvbmVudHMgd2hvc2UgbmFtZSBpcyBhbiBhbGlhcyB3aWxsIGJlXG4gKiB0cmFuc2Zvcm1lZCBhbmQgYWxsIG90aGVycyB3aWxsIGJlIGxlZnQgaW50YWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlQWxpYXNlcyhjb21wb25lbnRzOiBDb21wb25lbnRbXSk6IENvbXBvbmVudFtdIHtcbiAgcmV0dXJuIGZsYXRNYXAoY29tcG9uZW50cywgY29tcG9uZW50ID0+IHtcbiAgICBpZiAoY29tcG9uZW50Lm5hbWUgPT09ICdmcmFtZXdvcmsnKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgbmFtZTogJ0Bhd3MtY2RrL2NvcmUuJyxcbiAgICAgICAgdmVyc2lvbjogY29tcG9uZW50LnZlcnNpb24sXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdhd3MtY2RrLWxpYi4nLFxuICAgICAgICB2ZXJzaW9uOiBjb21wb25lbnQudmVyc2lvbixcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2NvbXBvbmVudF07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Tm90aWNlKG5vdGljZTogTm90aWNlKTogc3RyaW5nIHtcbiAgY29uc3QgY29tcG9uZW50c1ZhbHVlID0gbm90aWNlLmNvbXBvbmVudHMubWFwKGMgPT4gYCR7Yy5uYW1lfTogJHtjLnZlcnNpb259YCkuam9pbignLCAnKTtcbiAgcmV0dXJuIFtcbiAgICBgJHtub3RpY2UuaXNzdWVOdW1iZXJ9XFx0JHtub3RpY2UudGl0bGV9YCxcbiAgICBmb3JtYXRPdmVydmlldyhub3RpY2Uub3ZlcnZpZXcpLFxuICAgIGBcXHRBZmZlY3RlZCB2ZXJzaW9uczogJHtjb21wb25lbnRzVmFsdWV9YCxcbiAgICBgXFx0TW9yZSBpbmZvcm1hdGlvbiBhdDogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy8ke25vdGljZS5pc3N1ZU51bWJlcn1gLFxuICBdLmpvaW4oJ1xcblxcbicpICsgJ1xcbic7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE92ZXJ2aWV3KHRleHQ6IHN0cmluZykge1xuICBjb25zdCB3cmFwID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC8oPyFbXlxcbl17MSw2MH0kKShbXlxcbl17MSw2MH0pXFxzL2csICckMVxcbicpO1xuXG4gIGNvbnN0IGhlYWRpbmcgPSAnT3ZlcnZpZXc6ICc7XG4gIGNvbnN0IHNlcGFyYXRvciA9IGBcXG5cXHQkeycgJy5yZXBlYXQoaGVhZGluZy5sZW5ndGgpfWA7XG4gIGNvbnN0IGNvbnRlbnQgPSB3cmFwKHRleHQpXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5qb2luKHNlcGFyYXRvcik7XG5cbiAgcmV0dXJuICdcXHQnICsgaGVhZGluZyArIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogV2hldGhlciBhbnkgY29tcG9uZW50IGluIHRoZSB0cmVlIG1hdGNoZXMgYW55IGNvbXBvbmVudCBpbiB0aGUgcXVlcnkuXG4gKiBBIG1hdGNoIGhhcHBlbnMgd2hlbjpcbiAqXG4gKiAxLiBUaGUgdmVyc2lvbiBvZiB0aGUgbm9kZSBtYXRjaGVzIHRoZSB2ZXJzaW9uIGluIHRoZSBxdWVyeSwgaW50ZXJwcmV0ZWRcbiAqIGFzIGEgc2VtdmVyIHJhbmdlLlxuICpcbiAqIDIuIFRoZSBuYW1lIGluIHRoZSBxdWVyeSBpcyBhIHByZWZpeCBvZiB0aGUgbm9kZSBuYW1lIHdoZW4gdGhlIHF1ZXJ5IGVuZHMgaW4gJy4nLFxuICogb3IgdGhlIHR3byBuYW1lcyBhcmUgZXhhY3RseSB0aGUgc2FtZSwgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBtYXRjaChxdWVyeTogQ29tcG9uZW50W10sIHRyZWU6IENvbnN0cnVjdFRyZWVOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzb21lKHRyZWUsIG5vZGUgPT4ge1xuICAgIHJldHVybiBxdWVyeS5zb21lKGNvbXBvbmVudCA9PlxuICAgICAgY29tcGFyZU5hbWVzKGNvbXBvbmVudC5uYW1lLCBub2RlLmNvbnN0cnVjdEluZm8/LmZxbikgJiZcbiAgICAgIGNvbXBhcmVWZXJzaW9ucyhjb21wb25lbnQudmVyc2lvbiwgbm9kZS5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uKSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOYW1lcyhwYXR0ZXJuOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJldHVybiBwYXR0ZXJuLmVuZHNXaXRoKCcuJykgPyB0YXJnZXQuc3RhcnRzV2l0aChwYXR0ZXJuKSA6IHBhdHRlcm4gPT09IHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyhwYXR0ZXJuOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXModGFyZ2V0ID8/ICcnLCBwYXR0ZXJuKTtcbiAgfVxufVxuIl19