import { entityIdPathToken } from './constants.js';
import { validateStorageAccessPaths as _validateStorageAccessPaths } from './validate_storage_access_paths.js';
import { roleAccessBuilder as _roleAccessBuilder } from './access_builder.js';
import { AmplifyUserError } from '@aws-amplify/platform-core';
/**
 * Orchestrates the process of converting customer-defined storage access rules into corresponding IAM policies
 * and attaching those policies to the corresponding IAM roles
 */
export class StorageAccessOrchestrator {
    storageAccessGenerator;
    getInstanceProps;
    ssmEnvironmentEntries;
    policyFactory;
    validateStorageAccessPaths;
    roleAccessBuilder;
    /**
     * Maintains a mapping from a resource access acceptor to all of the access grants it has been configured with
     * Each entry of this map is fed into the policy generator to create a single policy for each acceptor
     */
    acceptorAccessMap = new Map();
    /**
     * Maintains pointers to the "deny" StoragePath Set for each access entry in the map above
     * This map is used during a final pass over all the StoragePaths to deny access on any paths where explicit allow rules were not specified
     */
    prefixDenyMap = new Map();
    /**
     * Instantiate with the access generator and other dependencies necessary for evaluating and constructing access policies
     * @param storageAccessGenerator The access callback defined by the customer
     * @param getInstanceProps props for fetching construct instances from the construct container
     * @param ssmEnvironmentEntries SSM context that should be passed to the ResourceAccessAcceptors when configuring access
     * @param policyFactory factory that generates IAM policies for various access control definitions
     * @param validateStorageAccessPaths validator function for checking access definition paths
     * @param roleAccessBuilder builder instance that is injected into the storageAccessGenerator to evaluate the rules
     */
    constructor(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory, validateStorageAccessPaths = _validateStorageAccessPaths, roleAccessBuilder = _roleAccessBuilder) {
        this.storageAccessGenerator = storageAccessGenerator;
        this.getInstanceProps = getInstanceProps;
        this.ssmEnvironmentEntries = ssmEnvironmentEntries;
        this.policyFactory = policyFactory;
        this.validateStorageAccessPaths = validateStorageAccessPaths;
        this.roleAccessBuilder = roleAccessBuilder;
    }
    /**
     * Orchestrates the process of translating the customer-provided storage access rules into IAM policies and attaching those policies to the appropriate roles.
     *
     * The high level steps are:
     * 1. Invokes the storageAccessGenerator to produce a storageAccessDefinition
     * 2. Validates the paths in the storageAccessDefinition
     * 3. Organizes the storageAccessDefinition into internally managed maps to facilitate translation into allow / deny rules on IAM policies
     * 4. Invokes the policy generator to produce a policy with appropriate allow / deny rules
     * 5. Invokes the resourceAccessAcceptors for each entry in the storageAccessDefinition to accept the corresponding IAM policy
     */
    orchestrateStorageAccess = () => {
        // storageAccessGenerator is the access callback defined by the customer
        // here we inject the roleAccessBuilder into the callback and run it
        // this produces the access definition that will be used to create the storage policies
        const storageAccessDefinition = this.storageAccessGenerator(this.roleAccessBuilder);
        // verify that the paths in the access definition are valid
        this.validateStorageAccessPaths(Object.keys(storageAccessDefinition));
        // iterate over the access definition and group permissions by ResourceAccessAcceptor
        Object.entries(storageAccessDefinition).forEach(([s3Prefix, accessPermissions]) => {
            const uniqueDefinitionIdSet = new Set();
            // iterate over all of the access definitions for a given prefix
            accessPermissions.forEach((permission) => {
                // iterate over all uniqueDefinitionIdValidations and ensure uniqueness within this path prefix
                permission.uniqueDefinitionIdValidations.forEach(({ uniqueDefinitionId, validationErrorOptions }) => {
                    if (uniqueDefinitionIdSet.has(uniqueDefinitionId)) {
                        throw new AmplifyUserError('InvalidStorageAccessDefinitionError', validationErrorOptions);
                    }
                    else {
                        uniqueDefinitionIdSet.add(uniqueDefinitionId);
                    }
                });
                // make the owner placeholder substitution in the s3 prefix
                const prefix = s3Prefix.replaceAll(entityIdPathToken, permission.idSubstitution);
                // replace "read" with "get" and "list" in actions
                const replaceReadWithGetAndList = permission.actions.flatMap((action) => (action === 'read' ? ['get', 'list'] : [action]));
                // ensure the actions list has no duplicates
                const noDuplicateActions = Array.from(new Set(replaceReadWithGetAndList));
                // set an entry that maps this permission to each resource acceptor
                permission.getResourceAccessAcceptors.forEach((getResourceAccessAcceptor) => {
                    this.addAccessDefinition(getResourceAccessAcceptor(this.getInstanceProps), noDuplicateActions, prefix);
                });
            });
        });
        // iterate over the access map entries and invoke each ResourceAccessAcceptor to accept the permissions
        this.attachPolicies(this.ssmEnvironmentEntries);
    };
    /**
     * Add an entry to the internal acceptorAccessMap and prefixDenyMap.
     * This entry defines a set of actions on a single s3 prefix that should be attached to a given ResourceAccessAcceptor
     */
    addAccessDefinition = (resourceAccessAcceptor, actions, s3Prefix) => {
        const acceptorToken = resourceAccessAcceptor.identifier;
        // if we haven't seen this token before, add it to the map
        if (!this.acceptorAccessMap.has(acceptorToken)) {
            this.acceptorAccessMap.set(acceptorToken, {
                accessMap: new Map(),
                acceptor: resourceAccessAcceptor,
            });
        }
        const accessMap = this.acceptorAccessMap.get(acceptorToken).accessMap;
        // add each action to the accessMap for this acceptorToken
        actions.forEach((action) => {
            if (!accessMap.has(action)) {
                // if we haven't seen this action for this acceptorToken before, add it to the map
                const allowSet = new Set([s3Prefix]);
                const denySet = new Set();
                accessMap.set(action, { allow: allowSet, deny: denySet });
                // this is where we create the reverse mapping that allows us to add entries to the denySet later by looking up the prefix
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
            else {
                // otherwise add the prefix to the existing allow set
                const { allow: allowSet, deny: denySet } = accessMap.get(action);
                allowSet.add(s3Prefix);
                // add an entry in the prefixDenyMap for the existing allow and deny set
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
        });
    };
    /**
     * Iterates over all of the access definitions that have been added to the orchestrator,
     * generates a policy for each accessMap,
     * and attaches the policy to the corresponding ResourceAccessAcceptor
     *
     * After this method is called, the existing access definition state is cleared.
     * This prevents multiple calls to this method from producing duplicate policies.
     * The class can continue to be used to build up state for a new set of policies if desired.
     * @param ssmEnvironmentEntries Additional SSM context that is passed to each ResourceAccessAcceptor
     */
    attachPolicies = (ssmEnvironmentEntries) => {
        const allPaths = Array.from(this.prefixDenyMap.keys());
        allPaths.forEach((storagePath) => {
            const parent = findParent(storagePath, allPaths);
            if (!parent) {
                return;
            }
            // if a parent path is defined, invoke the denyByDefault callback on this subpath for all policies that exist on the parent path
            this.prefixDenyMap
                .get(parent)
                ?.forEach((denyByDefaultCallback) => denyByDefaultCallback(storagePath));
        });
        this.acceptorAccessMap.forEach(({ acceptor, accessMap }) => {
            // removing subpaths from the allow set prevents unnecessary paths from being added to the policy
            // for example, if there are allow read rules for /foo/* and /foo/bar/* we only need to add /foo/* to the policy because that includes /foo/bar/*
            accessMap.forEach(({ allow }) => {
                removeSubPathsFromSet(allow);
            });
            acceptor.acceptResourceAccess(this.policyFactory.createPolicy(accessMap), ssmEnvironmentEntries);
        });
        this.acceptorAccessMap.clear();
        this.prefixDenyMap.clear();
    };
    setPrefixDenyMapEntry = (storagePath, allowPathSet, denyPathSet) => {
        // function that will add the denyPath to the denyPathSet unless the allowPathSet explicitly allows the path
        const setDenyByDefault = (denyPath) => {
            if (!allowPathSet.has(denyPath)) {
                denyPathSet.add(denyPath);
            }
        };
        if (!this.prefixDenyMap.has(storagePath)) {
            this.prefixDenyMap.set(storagePath, [setDenyByDefault]);
        }
        else {
            this.prefixDenyMap.get(storagePath)?.push(setDenyByDefault);
        }
    };
}
/**
 * This factory is really only necessary for allowing us to mock the StorageAccessOrchestrator in tests
 */
export class StorageAccessOrchestratorFactory {
    getInstance = (storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory) => new StorageAccessOrchestrator(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory);
}
/**
 * Returns the element in paths that is a prefix of path, if any
 * Note that there can only be one at this point because of upstream validation
 */
const findParent = (path, paths) => paths.find((p) => path !== p && path.startsWith(p.replaceAll('*', '')));
const removeSubPathsFromSet = (paths) => {
    paths.forEach((path) => {
        if (findParent(path, Array.from(paths))) {
            paths.delete(path);
        }
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZV9hY2Nlc3Nfb3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3N0b3JhZ2VfYWNjZXNzX29yY2hlc3RyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVuRCxPQUFPLEVBQUUsMEJBQTBCLElBQUksMkJBQTJCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUMvRyxPQUFPLEVBQUUsaUJBQWlCLElBQUksa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUU5RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQVU5RDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBZ0NqQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFwQ25COzs7T0FHRztJQUNLLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQVNoQyxDQUFDO0lBRUo7OztPQUdHO0lBQ0ssYUFBYSxHQUFHLElBQUksR0FBRyxFQUFtQyxDQUFDO0lBRW5FOzs7Ozs7OztPQVFHO0lBQ0gsWUFDbUIsc0JBQThDLEVBQzlDLGdCQUFrRCxFQUNsRCxxQkFBNEMsRUFDNUMsYUFBeUMsRUFDekMsNkJBQTZCLDJCQUEyQixFQUN4RCxvQkFBMEMsa0JBQWtCO1FBTDVELDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDOUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQztRQUNsRCwwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBQzVDLGtCQUFhLEdBQWIsYUFBYSxDQUE0QjtRQUN6QywrQkFBMEIsR0FBMUIsMEJBQTBCLENBQThCO1FBQ3hELHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMkM7SUFDNUUsQ0FBQztJQUVKOzs7Ozs7Ozs7T0FTRztJQUNILHdCQUF3QixHQUFHLEdBQUcsRUFBRTtRQUM5Qix3RUFBd0U7UUFDeEUsb0VBQW9FO1FB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dEluc3RhbmNlUHJvcHMsXG4gIFJlc291cmNlQWNjZXNzQWNjZXB0b3IsXG4gIFNzbUVudmlyb25tZW50RW50cnksXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHtcbiAgU3RvcmFnZUFjY2Vzc0J1aWxkZXIsXG4gIFN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gIFN0b3JhZ2VQYXRoLFxufSBmcm9tICcuL3R5cGVzLmpzJztcbmltcG9ydCB7IGVudGl0eUlkUGF0aFRva2VuIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnkgfSBmcm9tICcuL3N0b3JhZ2VfYWNjZXNzX3BvbGljeV9mYWN0b3J5LmpzJztcbmltcG9ydCB7IHZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzIGFzIF92YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyB9IGZyb20gJy4vdmFsaWRhdGVfc3RvcmFnZV9hY2Nlc3NfcGF0aHMuanMnO1xuaW1wb3J0IHsgcm9sZUFjY2Vzc0J1aWxkZXIgYXMgX3JvbGVBY2Nlc3NCdWlsZGVyIH0gZnJvbSAnLi9hY2Nlc3NfYnVpbGRlci5qcyc7XG5pbXBvcnQgeyBJbnRlcm5hbFN0b3JhZ2VBY3Rpb24sIFN0b3JhZ2VFcnJvciB9IGZyb20gJy4vcHJpdmF0ZV90eXBlcy5qcyc7XG5pbXBvcnQgeyBBbXBsaWZ5VXNlckVycm9yIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuXG4vKiBzb21lIHR5cGVzIGludGVybmFsIHRvIHRoaXMgZmlsZSB0byBpbXByb3ZlIHJlYWRhYmlsaXR5ICovXG5cbi8vIEFsaWFzIHR5cGUgZm9yIGEgc3RyaW5nIHRoYXQgaXMgYSBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yIHRva2VuXG50eXBlIEFjY2VwdG9yVG9rZW4gPSBzdHJpbmc7XG5cbi8vIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcGxhY2VzIHN0b3JhZ2VQYXRoIGluIHRoZSBkZW55IGxpc3QgZm9yIGFuIGFjdGlvbiBpZiBpdCBpcyBub3QgZXhwbGljaXRseSBhbGxvd2VkIGJ5IGFub3RoZXIgcnVsZVxudHlwZSBTZXREZW55QnlEZWZhdWx0ID0gKHN0b3JhZ2VQYXRoOiBTdG9yYWdlUGF0aCkgPT4gdm9pZDtcblxuLyoqXG4gKiBPcmNoZXN0cmF0ZXMgdGhlIHByb2Nlc3Mgb2YgY29udmVydGluZyBjdXN0b21lci1kZWZpbmVkIHN0b3JhZ2UgYWNjZXNzIHJ1bGVzIGludG8gY29ycmVzcG9uZGluZyBJQU0gcG9saWNpZXNcbiAqIGFuZCBhdHRhY2hpbmcgdGhvc2UgcG9saWNpZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgSUFNIHJvbGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yIHtcbiAgLyoqXG4gICAqIE1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHJlc291cmNlIGFjY2VzcyBhY2NlcHRvciB0byBhbGwgb2YgdGhlIGFjY2VzcyBncmFudHMgaXQgaGFzIGJlZW4gY29uZmlndXJlZCB3aXRoXG4gICAqIEVhY2ggZW50cnkgb2YgdGhpcyBtYXAgaXMgZmVkIGludG8gdGhlIHBvbGljeSBnZW5lcmF0b3IgdG8gY3JlYXRlIGEgc2luZ2xlIHBvbGljeSBmb3IgZWFjaCBhY2NlcHRvclxuICAgKi9cbiAgcHJpdmF0ZSBhY2NlcHRvckFjY2Vzc01hcCA9IG5ldyBNYXA8XG4gICAgQWNjZXB0b3JUb2tlbixcbiAgICB7XG4gICAgICBhY2NlcHRvcjogUmVzb3VyY2VBY2Nlc3NBY2NlcHRvcjtcbiAgICAgIGFjY2Vzc01hcDogTWFwPFxuICAgICAgICBJbnRlcm5hbFN0b3JhZ2VBY3Rpb24sXG4gICAgICAgIHsgYWxsb3c6IFNldDxTdG9yYWdlUGF0aD47IGRlbnk6IFNldDxTdG9yYWdlUGF0aD4gfVxuICAgICAgPjtcbiAgICB9XG4gID4oKTtcblxuICAvKipcbiAgICogTWFpbnRhaW5zIHBvaW50ZXJzIHRvIHRoZSBcImRlbnlcIiBTdG9yYWdlUGF0aCBTZXQgZm9yIGVhY2ggYWNjZXNzIGVudHJ5IGluIHRoZSBtYXAgYWJvdmVcbiAgICogVGhpcyBtYXAgaXMgdXNlZCBkdXJpbmcgYSBmaW5hbCBwYXNzIG92ZXIgYWxsIHRoZSBTdG9yYWdlUGF0aHMgdG8gZGVueSBhY2Nlc3Mgb24gYW55IHBhdGhzIHdoZXJlIGV4cGxpY2l0IGFsbG93IHJ1bGVzIHdlcmUgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgcHJpdmF0ZSBwcmVmaXhEZW55TWFwID0gbmV3IE1hcDxTdG9yYWdlUGF0aCwgU2V0RGVueUJ5RGVmYXVsdFtdPigpO1xuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSB3aXRoIHRoZSBhY2Nlc3MgZ2VuZXJhdG9yIGFuZCBvdGhlciBkZXBlbmRlbmNpZXMgbmVjZXNzYXJ5IGZvciBldmFsdWF0aW5nIGFuZCBjb25zdHJ1Y3RpbmcgYWNjZXNzIHBvbGljaWVzXG4gICAqIEBwYXJhbSBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yIFRoZSBhY2Nlc3MgY2FsbGJhY2sgZGVmaW5lZCBieSB0aGUgY3VzdG9tZXJcbiAgICogQHBhcmFtIGdldEluc3RhbmNlUHJvcHMgcHJvcHMgZm9yIGZldGNoaW5nIGNvbnN0cnVjdCBpbnN0YW5jZXMgZnJvbSB0aGUgY29uc3RydWN0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0gc3NtRW52aXJvbm1lbnRFbnRyaWVzIFNTTSBjb250ZXh0IHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMgd2hlbiBjb25maWd1cmluZyBhY2Nlc3NcbiAgICogQHBhcmFtIHBvbGljeUZhY3RvcnkgZmFjdG9yeSB0aGF0IGdlbmVyYXRlcyBJQU0gcG9saWNpZXMgZm9yIHZhcmlvdXMgYWNjZXNzIGNvbnRyb2wgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzIHZhbGlkYXRvciBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgYWNjZXNzIGRlZmluaXRpb24gcGF0aHNcbiAgICogQHBhcmFtIHJvbGVBY2Nlc3NCdWlsZGVyIGJ1aWxkZXIgaW5zdGFuY2UgdGhhdCBpcyBpbmplY3RlZCBpbnRvIHRoZSBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yIHRvIGV2YWx1YXRlIHRoZSBydWxlc1xuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yOiBTdG9yYWdlQWNjZXNzR2VuZXJhdG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ2V0SW5zdGFuY2VQcm9wczogQ29uc3RydWN0RmFjdG9yeUdldEluc3RhbmNlUHJvcHMsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzc21FbnZpcm9ubWVudEVudHJpZXM6IFNzbUVudmlyb25tZW50RW50cnlbXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBvbGljeUZhY3Rvcnk6IFN0b3JhZ2VBY2Nlc3NQb2xpY3lGYWN0b3J5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMgPSBfdmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMsXG4gICAgcHJpdmF0ZSByZWFkb25seSByb2xlQWNjZXNzQnVpbGRlcjogU3RvcmFnZUFjY2Vzc0J1aWxkZXIgPSBfcm9sZUFjY2Vzc0J1aWxkZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBPcmNoZXN0cmF0ZXMgdGhlIHByb2Nlc3Mgb2YgdHJhbnNsYXRpbmcgdGhlIGN1c3RvbWVyLXByb3ZpZGVkIHN0b3JhZ2UgYWNjZXNzIHJ1bGVzIGludG8gSUFNIHBvbGljaWVzIGFuZCBhdHRhY2hpbmcgdGhvc2UgcG9saWNpZXMgdG8gdGhlIGFwcHJvcHJpYXRlIHJvbGVzLlxuICAgKlxuICAgKiBUaGUgaGlnaCBsZXZlbCBzdGVwcyBhcmU6XG4gICAqIDEuIEludm9rZXMgdGhlIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IgdG8gcHJvZHVjZSBhIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uXG4gICAqIDIuIFZhbGlkYXRlcyB0aGUgcGF0aHMgaW4gdGhlIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uXG4gICAqIDMuIE9yZ2FuaXplcyB0aGUgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24gaW50byBpbnRlcm5hbGx5IG1hbmFnZWQgbWFwcyB0byBmYWNpbGl0YXRlIHRyYW5zbGF0aW9uIGludG8gYWxsb3cgLyBkZW55IHJ1bGVzIG9uIElBTSBwb2xpY2llc1xuICAgKiA0LiBJbnZva2VzIHRoZSBwb2xpY3kgZ2VuZXJhdG9yIHRvIHByb2R1Y2UgYSBwb2xpY3kgd2l0aCBhcHByb3ByaWF0ZSBhbGxvdyAvIGRlbnkgcnVsZXNcbiAgICogNS4gSW52b2tlcyB0aGUgcmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMgZm9yIGVhY2ggZW50cnkgaW4gdGhlIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uIHRvIGFjY2VwdCB0aGUgY29ycmVzcG9uZGluZyBJQU0gcG9saWN5XG4gICAqL1xuICBvcmNoZXN0cmF0ZVN0b3JhZ2VBY2Nlc3MgPSAoKSA9PiB7XG4gICAgLy8gc3RvcmFnZUFjY2Vzc0dlbmVyYXRvciBpcyB0aGUgYWNjZXNzIGNhbGxiYWNrIGRlZmluZWQgYnkgdGhlIGN1c3RvbWVyXG4gICAgLy8gaGVyZSB3ZSBpbmplY3QgdGhlIHJvbGVBY2Nlc3NCdWlsZGVyIGludG8gdGhlIGNhbGxiYWNrIGFuZCBydW4gaXRcbiAgICAvLyB0aGlzIHByb2R1Y2VzIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JhZ2UgcG9saWNpZXNcbiAgICBjb25zdCBzdG9yYWdlQWNjZXNzRGVmaW5pdGlvbiA9IHRoaXMuc3RvcmFnZUFjY2Vzc0dlbmVyYXRvcihcbiAgICAgIHRoaXMucm9sZUFjY2Vzc0J1aWxkZXJcbiAgICApO1xuXG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhlIHBhdGhzIGluIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbiBhcmUgdmFsaWRcbiAgICB0aGlzLnZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzKE9iamVjdC5rZXlzKHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uKSk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGFjY2VzcyBkZWZpbml0aW9uIGFuZCBncm91cCBwZXJtaXNzaW9ucyBieSBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yXG4gICAgT2JqZWN0LmVudHJpZXMoc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24pLmZvckVhY2goXG4gICAgICAoW3MzUHJlZml4LCBhY2Nlc3NQZXJtaXNzaW9uc10pID0+IHtcbiAgICAgICAgY29uc3QgdW5pcXVlRGVmaW5pdGlvbklkU2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgb2YgdGhlIGFjY2VzcyBkZWZpbml0aW9ucyBmb3IgYSBnaXZlbiBwcmVmaXhcbiAgICAgICAgYWNjZXNzUGVybWlzc2lvbnMuZm9yRWFjaCgocGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgdW5pcXVlRGVmaW5pdGlvbklkVmFsaWRhdGlvbnMgYW5kIGVuc3VyZSB1bmlxdWVuZXNzIHdpdGhpbiB0aGlzIHBhdGggcHJlZml4XG4gICAgICAgICAgcGVybWlzc2lvbi51bmlxdWVEZWZpbml0aW9uSWRWYWxpZGF0aW9ucy5mb3JFYWNoKFxuICAgICAgICAgICAgKHsgdW5pcXVlRGVmaW5pdGlvbklkLCB2YWxpZGF0aW9uRXJyb3JPcHRpb25zIH0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKHVuaXF1ZURlZmluaXRpb25JZFNldC5oYXModW5pcXVlRGVmaW5pdGlvbklkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZFN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uRXJyb3InLFxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yT3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlRGVmaW5pdGlvbklkU2V0LmFkZCh1bmlxdWVEZWZpbml0aW9uSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBtYWtlIHRoZSBvd25lciBwbGFjZWhvbGRlciBzdWJzdGl0dXRpb24gaW4gdGhlIHMzIHByZWZpeFxuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHMzUHJlZml4LnJlcGxhY2VBbGwoXG4gICAgICAgICAgICBlbnRpdHlJZFBhdGhUb2tlbixcbiAgICAgICAgICAgIHBlcm1pc3Npb24uaWRTdWJzdGl0dXRpb25cbiAgICAgICAgICApIGFzIFN0b3JhZ2VQYXRoO1xuXG4gICAgICAgICAgLy8gcmVwbGFjZSBcInJlYWRcIiB3aXRoIFwiZ2V0XCIgYW5kIFwibGlzdFwiIGluIGFjdGlvbnNcbiAgICAgICAgICBjb25zdCByZXBsYWNlUmVhZFdpdGhHZXRBbmRMaXN0ID0gcGVybWlzc2lvbi5hY3Rpb25zLmZsYXRNYXAoXG4gICAgICAgICAgICAoYWN0aW9uKSA9PiAoYWN0aW9uID09PSAncmVhZCcgPyBbJ2dldCcsICdsaXN0J10gOiBbYWN0aW9uXSlcbiAgICAgICAgICApIGFzIEludGVybmFsU3RvcmFnZUFjdGlvbltdO1xuXG4gICAgICAgICAgLy8gZW5zdXJlIHRoZSBhY3Rpb25zIGxpc3QgaGFzIG5vIGR1cGxpY2F0ZXNcbiAgICAgICAgICBjb25zdCBub0R1cGxpY2F0ZUFjdGlvbnMgPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgbmV3IFNldChyZXBsYWNlUmVhZFdpdGhHZXRBbmRMaXN0KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBzZXQgYW4gZW50cnkgdGhhdCBtYXBzIHRoaXMgcGVybWlzc2lvbiB0byBlYWNoIHJlc291cmNlIGFjY2VwdG9yXG4gICAgICAgICAgcGVybWlzc2lvbi5nZXRSZXNvdXJjZUFjY2Vzc0FjY2VwdG9ycy5mb3JFYWNoKFxuICAgICAgICAgICAgKGdldFJlc291cmNlQWNjZXNzQWNjZXB0b3IpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRBY2Nlc3NEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgIGdldFJlc291cmNlQWNjZXNzQWNjZXB0b3IodGhpcy5nZXRJbnN0YW5jZVByb3BzKSxcbiAgICAgICAgICAgICAgICBub0R1cGxpY2F0ZUFjdGlvbnMsXG4gICAgICAgICAgICAgICAgcHJlZml4XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgYWNjZXNzIG1hcCBlbnRyaWVzIGFuZCBpbnZva2UgZWFjaCBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yIHRvIGFjY2VwdCB0aGUgcGVybWlzc2lvbnNcbiAgICB0aGlzLmF0dGFjaFBvbGljaWVzKHRoaXMuc3NtRW52aXJvbm1lbnRFbnRyaWVzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIGVudHJ5IHRvIHRoZSBpbnRlcm5hbCBhY2NlcHRvckFjY2Vzc01hcCBhbmQgcHJlZml4RGVueU1hcC5cbiAgICogVGhpcyBlbnRyeSBkZWZpbmVzIGEgc2V0IG9mIGFjdGlvbnMgb24gYSBzaW5nbGUgczMgcHJlZml4IHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIGEgZ2l2ZW4gUmVzb3VyY2VBY2Nlc3NBY2NlcHRvclxuICAgKi9cbiAgcHJpdmF0ZSBhZGRBY2Nlc3NEZWZpbml0aW9uID0gKFxuICAgIHJlc291cmNlQWNjZXNzQWNjZXB0b3I6IFJlc291cmNlQWNjZXNzQWNjZXB0b3IsXG4gICAgYWN0aW9uczogSW50ZXJuYWxTdG9yYWdlQWN0aW9uW10sXG4gICAgczNQcmVmaXg6IFN0b3JhZ2VQYXRoXG4gICkgPT4ge1xuICAgIGNvbnN0IGFjY2VwdG9yVG9rZW4gPSByZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLmlkZW50aWZpZXI7XG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHNlZW4gdGhpcyB0b2tlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgbWFwXG4gICAgaWYgKCF0aGlzLmFjY2VwdG9yQWNjZXNzTWFwLmhhcyhhY2NlcHRvclRva2VuKSkge1xuICAgICAgdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5zZXQoYWNjZXB0b3JUb2tlbiwge1xuICAgICAgICBhY2Nlc3NNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgYWNjZXB0b3I6IHJlc291cmNlQWNjZXNzQWNjZXB0b3IsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYWNjZXNzTWFwID0gdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5nZXQoYWNjZXB0b3JUb2tlbikhLmFjY2Vzc01hcDtcbiAgICAvLyBhZGQgZWFjaCBhY3Rpb24gdG8gdGhlIGFjY2Vzc01hcCBmb3IgdGhpcyBhY2NlcHRvclRva2VuXG4gICAgYWN0aW9ucy5mb3JFYWNoKChhY3Rpb24pID0+IHtcbiAgICAgIGlmICghYWNjZXNzTWFwLmhhcyhhY3Rpb24pKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmVuJ3Qgc2VlbiB0aGlzIGFjdGlvbiBmb3IgdGhpcyBhY2NlcHRvclRva2VuIGJlZm9yZSwgYWRkIGl0IHRvIHRoZSBtYXBcbiAgICAgICAgY29uc3QgYWxsb3dTZXQgPSBuZXcgU2V0PFN0b3JhZ2VQYXRoPihbczNQcmVmaXhdKTtcbiAgICAgICAgY29uc3QgZGVueVNldCA9IG5ldyBTZXQ8U3RvcmFnZVBhdGg+KCk7XG4gICAgICAgIGFjY2Vzc01hcC5zZXQoYWN0aW9uLCB7IGFsbG93OiBhbGxvd1NldCwgZGVueTogZGVueVNldCB9KTtcblxuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIGNyZWF0ZSB0aGUgcmV2ZXJzZSBtYXBwaW5nIHRoYXQgYWxsb3dzIHVzIHRvIGFkZCBlbnRyaWVzIHRvIHRoZSBkZW55U2V0IGxhdGVyIGJ5IGxvb2tpbmcgdXAgdGhlIHByZWZpeFxuICAgICAgICB0aGlzLnNldFByZWZpeERlbnlNYXBFbnRyeShzM1ByZWZpeCwgYWxsb3dTZXQsIGRlbnlTZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGFkZCB0aGUgcHJlZml4IHRvIHRoZSBleGlzdGluZyBhbGxvdyBzZXRcbiAgICAgICAgY29uc3QgeyBhbGxvdzogYWxsb3dTZXQsIGRlbnk6IGRlbnlTZXQgfSA9IGFjY2Vzc01hcC5nZXQoYWN0aW9uKSE7XG4gICAgICAgIGFsbG93U2V0LmFkZChzM1ByZWZpeCk7XG5cbiAgICAgICAgLy8gYWRkIGFuIGVudHJ5IGluIHRoZSBwcmVmaXhEZW55TWFwIGZvciB0aGUgZXhpc3RpbmcgYWxsb3cgYW5kIGRlbnkgc2V0XG4gICAgICAgIHRoaXMuc2V0UHJlZml4RGVueU1hcEVudHJ5KHMzUHJlZml4LCBhbGxvd1NldCwgZGVueVNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYWxsIG9mIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbnMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIG9yY2hlc3RyYXRvcixcbiAgICogZ2VuZXJhdGVzIGEgcG9saWN5IGZvciBlYWNoIGFjY2Vzc01hcCxcbiAgICogYW5kIGF0dGFjaGVzIHRoZSBwb2xpY3kgdG8gdGhlIGNvcnJlc3BvbmRpbmcgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvclxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBleGlzdGluZyBhY2Nlc3MgZGVmaW5pdGlvbiBzdGF0ZSBpcyBjbGVhcmVkLlxuICAgKiBUaGlzIHByZXZlbnRzIG11bHRpcGxlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIGZyb20gcHJvZHVjaW5nIGR1cGxpY2F0ZSBwb2xpY2llcy5cbiAgICogVGhlIGNsYXNzIGNhbiBjb250aW51ZSB0byBiZSB1c2VkIHRvIGJ1aWxkIHVwIHN0YXRlIGZvciBhIG5ldyBzZXQgb2YgcG9saWNpZXMgaWYgZGVzaXJlZC5cbiAgICogQHBhcmFtIHNzbUVudmlyb25tZW50RW50cmllcyBBZGRpdGlvbmFsIFNTTSBjb250ZXh0IHRoYXQgaXMgcGFzc2VkIHRvIGVhY2ggUmVzb3VyY2VBY2Nlc3NBY2NlcHRvclxuICAgKi9cbiAgcHJpdmF0ZSBhdHRhY2hQb2xpY2llcyA9IChzc21FbnZpcm9ubWVudEVudHJpZXM6IFNzbUVudmlyb25tZW50RW50cnlbXSkgPT4ge1xuICAgIGNvbnN0IGFsbFBhdGhzID0gQXJyYXkuZnJvbSh0aGlzLnByZWZpeERlbnlNYXAua2V5cygpKTtcbiAgICBhbGxQYXRocy5mb3JFYWNoKChzdG9yYWdlUGF0aCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gZmluZFBhcmVudChzdG9yYWdlUGF0aCwgYWxsUGF0aHMpO1xuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaWYgYSBwYXJlbnQgcGF0aCBpcyBkZWZpbmVkLCBpbnZva2UgdGhlIGRlbnlCeURlZmF1bHQgY2FsbGJhY2sgb24gdGhpcyBzdWJwYXRoIGZvciBhbGwgcG9saWNpZXMgdGhhdCBleGlzdCBvbiB0aGUgcGFyZW50IHBhdGhcbiAgICAgIHRoaXMucHJlZml4RGVueU1hcFxuICAgICAgICAuZ2V0KHBhcmVudClcbiAgICAgICAgPy5mb3JFYWNoKChkZW55QnlEZWZhdWx0Q2FsbGJhY2spID0+XG4gICAgICAgICAgZGVueUJ5RGVmYXVsdENhbGxiYWNrKHN0b3JhZ2VQYXRoKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5mb3JFYWNoKCh7IGFjY2VwdG9yLCBhY2Nlc3NNYXAgfSkgPT4ge1xuICAgICAgLy8gcmVtb3Zpbmcgc3VicGF0aHMgZnJvbSB0aGUgYWxsb3cgc2V0IHByZXZlbnRzIHVubmVjZXNzYXJ5IHBhdGhzIGZyb20gYmVpbmcgYWRkZWQgdG8gdGhlIHBvbGljeVxuICAgICAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZXJlIGFyZSBhbGxvdyByZWFkIHJ1bGVzIGZvciAvZm9vLyogYW5kIC9mb28vYmFyLyogd2Ugb25seSBuZWVkIHRvIGFkZCAvZm9vLyogdG8gdGhlIHBvbGljeSBiZWNhdXNlIHRoYXQgaW5jbHVkZXMgL2Zvby9iYXIvKlxuICAgICAgYWNjZXNzTWFwLmZvckVhY2goKHsgYWxsb3cgfSkgPT4ge1xuICAgICAgICByZW1vdmVTdWJQYXRoc0Zyb21TZXQoYWxsb3cpO1xuICAgICAgfSk7XG4gICAgICBhY2NlcHRvci5hY2NlcHRSZXNvdXJjZUFjY2VzcyhcbiAgICAgICAgdGhpcy5wb2xpY3lGYWN0b3J5LmNyZWF0ZVBvbGljeShhY2Nlc3NNYXApLFxuICAgICAgICBzc21FbnZpcm9ubWVudEVudHJpZXNcbiAgICAgICk7XG4gICAgfSk7XG4gICAgdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5jbGVhcigpO1xuICAgIHRoaXMucHJlZml4RGVueU1hcC5jbGVhcigpO1xuICB9O1xuXG4gIHByaXZhdGUgc2V0UHJlZml4RGVueU1hcEVudHJ5ID0gKFxuICAgIHN0b3JhZ2VQYXRoOiBTdG9yYWdlUGF0aCxcbiAgICBhbGxvd1BhdGhTZXQ6IFNldDxTdG9yYWdlUGF0aD4sXG4gICAgZGVueVBhdGhTZXQ6IFNldDxTdG9yYWdlUGF0aD5cbiAgKSA9PiB7XG4gICAgLy8gZnVuY3Rpb24gdGhhdCB3aWxsIGFkZCB0aGUgZGVueVBhdGggdG8gdGhlIGRlbnlQYXRoU2V0IHVubGVzcyB0aGUgYWxsb3dQYXRoU2V0IGV4cGxpY2l0bHkgYWxsb3dzIHRoZSBwYXRoXG4gICAgY29uc3Qgc2V0RGVueUJ5RGVmYXVsdCA9IChkZW55UGF0aDogU3RvcmFnZVBhdGgpID0+IHtcbiAgICAgIGlmICghYWxsb3dQYXRoU2V0LmhhcyhkZW55UGF0aCkpIHtcbiAgICAgICAgZGVueVBhdGhTZXQuYWRkKGRlbnlQYXRoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghdGhpcy5wcmVmaXhEZW55TWFwLmhhcyhzdG9yYWdlUGF0aCkpIHtcbiAgICAgIHRoaXMucHJlZml4RGVueU1hcC5zZXQoc3RvcmFnZVBhdGgsIFtzZXREZW55QnlEZWZhdWx0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlZml4RGVueU1hcC5nZXQoc3RvcmFnZVBhdGgpPy5wdXNoKHNldERlbnlCeURlZmF1bHQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZhY3RvcnkgaXMgcmVhbGx5IG9ubHkgbmVjZXNzYXJ5IGZvciBhbGxvd2luZyB1cyB0byBtb2NrIHRoZSBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yIGluIHRlc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yRmFjdG9yeSB7XG4gIGdldEluc3RhbmNlID0gKFxuICAgIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3I6IFN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gICAgZ2V0SW5zdGFuY2VQcm9wczogQ29uc3RydWN0RmFjdG9yeUdldEluc3RhbmNlUHJvcHMsXG4gICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzOiBTc21FbnZpcm9ubWVudEVudHJ5W10sXG4gICAgcG9saWN5RmFjdG9yeTogU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnlcbiAgKSA9PlxuICAgIG5ldyBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yKFxuICAgICAgc3RvcmFnZUFjY2Vzc0dlbmVyYXRvcixcbiAgICAgIGdldEluc3RhbmNlUHJvcHMsXG4gICAgICBzc21FbnZpcm9ubWVudEVudHJpZXMsXG4gICAgICBwb2xpY3lGYWN0b3J5XG4gICAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGluIHBhdGhzIHRoYXQgaXMgYSBwcmVmaXggb2YgcGF0aCwgaWYgYW55XG4gKiBOb3RlIHRoYXQgdGhlcmUgY2FuIG9ubHkgYmUgb25lIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBvZiB1cHN0cmVhbSB2YWxpZGF0aW9uXG4gKi9cbmNvbnN0IGZpbmRQYXJlbnQgPSAocGF0aDogc3RyaW5nLCBwYXRoczogc3RyaW5nW10pID0+XG4gIHBhdGhzLmZpbmQoKHApID0+IHBhdGggIT09IHAgJiYgcGF0aC5zdGFydHNXaXRoKHAucmVwbGFjZUFsbCgnKicsICcnKSkpIGFzXG4gICAgfCBTdG9yYWdlUGF0aFxuICAgIHwgdW5kZWZpbmVkO1xuXG5jb25zdCByZW1vdmVTdWJQYXRoc0Zyb21TZXQgPSAocGF0aHM6IFNldDxTdG9yYWdlUGF0aD4pID0+IHtcbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGlmIChmaW5kUGFyZW50KHBhdGgsIEFycmF5LmZyb20ocGF0aHMpKSkge1xuICAgICAgcGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgIH1cbiAgfSk7XG59O1xuIl19